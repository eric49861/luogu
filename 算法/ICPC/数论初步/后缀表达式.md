## [后缀表达式](https://www.educoder.net/tasks/25khlec8t3sz)

> 题目描述

给定`N`个加号，`M`个减号，以及`N+M+1`个整数`A1，A2，…，An+m+1`，小明想知道在所有由这`N`个加号、`M`个减号以及`N+M+1`个整数凑出的合法的后缀表达式中，结果最大的是哪一个。 请你输出这个最大的结果。 例如使用`1 2 3 + -`，则`“2 3 + 1 –”`这个后缀表达式结果是`4`，是最大的。 对于所有样例，`0<=N，M<=100000，-10^9<=Ai<=10^9`。6

> 解题思路

首先分情况进行讨论减号的数量和负数的数量的关系：

1. 减号的数量为0

   这种情况下，只有一个结果，$ans = \sum_{i=1}^{i=n+m+1}{a_i}$

2. 减号的数量不为0

   这种情况下又分为三种情况

   - 减号的数量等于负数的数量

     $ans = \sum_{i=1}^{i=n+m+1}{|a_i|}$

   - 当减号的数量小于负数的数量

     $ans=max+\sum{|其余数|}$

   - 当减号的数量大于负数的数量

     $ans = \sum{|其余数|} - min$

   上述三种情况中第一种可能是最好理解的，将所有的负数恰好全变为正数，相当于对所有的数取了绝对值。

   第二种情况下，考虑将几个负数进行求和，然后使用其他的数减去这几个负数的和，这样可以减少负号的使用，但是可以让多个负数变成正数，此时仍然相当于是对负数取了绝对值。但是我们不可能让负号开头，就是总得有个数减去这些负数，那这个数显然是该序列中的最大值。

   第三种情况下，这样考虑，那最小值依次减去比它大的数，然后再使用一个数减去这个结果。举个例子：

   > N = 1, M = 4        序列：-1、1、2、3、4、5
   >
   > ans = 5 - ((-1) - 1 - 2 - 3) + 4= 5 + 4 + 3 + 2 + 1 - (-1)

​		 这样使用负号将每一个负数进行取反，然后剩余的数使用负号抵消负号，但是需要减去最小值。(只是相当于这样想)

最后将这几条结论归纳为

$ans = max + \sum{|其它数|} - min$

重新考虑上述的三个条件：

- 第一种情况相等的时候，最小值一定小于0，减去最小值还是取绝对值，至少有一个数是正数，所以最大值还是正数。
- 第二种情况小于的时候，最小值一定小于0
- 第三种情况大于的时候，最大值一定大于0

```C++
#include <iostream>
#include <string.h>
#include <algorithm>
#include <cmath>
using namespace std;

int main(){
    int N, M;
    while(cin >> N >> M){
        long arr[M+N+1];
        long ans = 0;
        for(int i = 0; i < N+M+1; i++){
            cin >> arr[i];
        }
        sort(arr, arr+N+M+1);
        if(M == 0){
            for(int i = 0; i < N+M+1; i++){
                ans += arr[i];
            }
            cout << ans << endl;
        }else{
            for(int i = 1; i < N+M; i++){
                ans += abs(arr[i]);
            }
            ans += arr[M+N];
            ans -= arr[0];
            cout << ans << endl;
        }
    }
    
    return 0;
}
```

