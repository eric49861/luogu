# [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

> 题目描述

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

> 解题思路

使用一个指针始终指向当前的最后一个丑数，其实就是将当前丑数分别乘以2/3/5，然后将这些将得到的结果进行排序，所以自然可以想到使用小根堆的方式来实现，因为在反复计算的过程中会有重复的丑数，所以可以使用hash来减少重复的插入操作。

上述方式比较容易理解而且较容易实现，所以这里没有给出代码。当然，这里主要关注使用动态规划的思想来解题，这道题的转移方程不是非常容易想到，但是如果能想到使用小根堆的方式，其实也差不多了。

我们创建三个指针，初始化的时候全部指向第一个丑数 1 所在的位置，然后分别将这些指针所对应的丑数乘以2/3/5，最终取三者的较小值，当然其中很可能有重复的结果，此时将结果为该最小值的指针向前移动一个位置。

> 重复的情况：
>
> 假设p2指向的数字要乘以2，指p3指向的丑数要乘以3，当p2指向3并且p3指向2时就会重复，此时两个指针都应该移动。
>
> 已经验证过，有可能会发生该种情况。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for(int i = 1; i < n; i++){
            dp[i] = Math.min(Math.min(dp[p2]*2, dp[p3]*3), dp[p5]*5);
            if(dp[i] == dp[p2]*2){
                p2++;
            }
            if(dp[i] == dp[p3]*3){
                p3++;
            }
            if(dp[i] == dp[p5]*5){
                p5++;
            }
        }
        return dp[n-1];
    }
}
```

